# 运行架构

当前项目以最小化脚本形式运作，整体架构非常简单：

```
+---------------------+
|  定时调度 (schedule) |
+----------+----------+
           |
           v
+----------+----------+
|  预约流程控制 book.py |
+----------+----------+
           |
           v
+----------+----------+
|  会话管理 login.py    |
+----------+----------+
           |
           v
+----------+----------+
|  场地数据 fetch_data   |
+----------+----------+
           |
           v
+----------+----------+
|  配置 config/config_setup |
+---------------------+
```

## 关键阶段

1. **配置阶段**
   - `config.py` 定义账号、时间策略、场馆偏好等静态信息。
   - `config_setup.py` 根据配置调用学校接口，筛选出符合偏好的场地，并写入 `Config.BOOKING_DATA`。

2. **执行阶段**
   - `scheduler.py` 使用 `schedule` 库，按照 `Config.SCHEDULE_TIME` 配置的时间触发预约。
   - 在允许的时间段 (`Config.BOOKING_HOURS`) 内调用 `Booking.book_venue()`，失败时根据返回信息自动重试。

3. **数据缓存**
   - `fetch_data.py` 会在 `backend/data/` 下生成 JSON 缓存，避免短时间内重复访问同一日期的接口。

## 组件说明

| 组件 | 职责 |
| --- | --- |
| `config.py` | 集中管理账号、偏好、调度时间等常量 |
| `config_setup.py` | 拉取场地数据并写入 `Config.BOOKING_DATA` |
| `fetch_data.py` | 封装带登录态的 HTTP 请求，支持缓存 |
| `login.py` | 登录学校系统，返回可复用的 `requests.Session` |
| `book.py` | 根据当前配置构造预约请求并自动重试 |
| `scheduler.py` | 每日定时运行预约流程 |

## 调度逻辑

- 程序启动时先调用 `setup_config()`，如果获取失败会按设定间隔重试。
- 进入调度循环后，每分钟检查一次是否到达 `SCHEDULE_TIME`。
- 只要当前时间位于 `BOOKING_HOURS` 内，就尝试执行预约。
- 如果发现首选日期变化（`booking_date_candidates()` 返回的首位发生改变），会自动重新跑一次 `setup_config()`。

## 与旧架构的区别

- 不再包含 FastAPI/CLI 层，也不依赖数据库、仓储模式等复杂抽象。
- 所有状态均在内存中维护，必要时借助 JSON 文件缓存。
- 调度器完全基于 `schedule` 与 `time` 模块，无额外框架。

这套架构的目标是保证脚本轻量、易部署、易维护，同时可按需扩展（例如将预约结果写入日志、对接通知渠道等）。
